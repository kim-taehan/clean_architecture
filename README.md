# Clean Architecture

## [1장 설계와 아키텍쳐](1장%20설계와%20아키텍쳐//README.md) 
- 빨리 가는 유일한 방법은 제대로 가는 것이다

## [2장 두가지 가치에 대한 이야기](2장%20두가지%20가치에%20대한%20이야기/README.md)
- 아키텍처를 위해 투쟁하라 (행위보다는 구조)

## [3장 패러다임 개요](3장%20패러다임%20개요/README.md)
- 구조적 프로그래밍, 객체지향 프로그래밍, 함수형 프로그래밍

## [4장 구조적 프로그래밍](4장%20구조적%20프로그래밍/README.md)
- 프로그램의 논리 구조는 제한된 몇 가지 방법만을 이용하여 비슷한 서브 프로그램들로 구성된다

## [5장 객체지향 프로그래밍](5장%20객체지향%20프로그래밍/README.md)
- 캡슐화, 상속, 다형성을 지원하는 프로그래밍
- 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 제어권한을 획득한다.

## [6장 함수형 프로그래밍](6장%20함수형%20프로그래밍/README.md)
- 자료 처리를 수학적 함수의 계산으로 취급하고 상태와 가변 데이터를 멀리하는 프로그래밍 패러다임

## [7장 단일 책임 원칙](7장%20단일%20책임%20원칙/README.md)
- 단일 모듈은 변경의 이유가 하나, 오직 하나뿐이어야 한다.

## [8장 개방 폐쇄 원칙](8장%20개방%20폐쇄%20원칙/README.md)
- 소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.

## [9장 리스코프 치환 원칙](9장%20리스코프%20치환%20원칙/README.md)
- 상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들려면, 
- 이들 구성요소는 반드시 서로 치환 가능해야 한다.

## [10장 인터페이스 분리 원칙](10장%20인터페이스%20분리%20원칙/README.md)
- 소프트웨어 설계자는 사용하지 않은 것에 의존하지 않아야 된다.

## [11장 의존성 역전 원칙](11장%20의존성%20역전%20원칙/README.md)
- 고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안된다.

## [12장 컴포넌트](12장%컴포넌트/README.md)
- 컴포넌트는 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위 (자바는 jar)

## [13장 컴포넌트 응집도](13장%20컴포넌트%20응집도/README.md)
- 컴포넌트 응집도 3가지 법칙 재사용/릴리스 등가, 공통 폐쇄, 공통 재사용 원칙

